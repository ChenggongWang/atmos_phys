<HTML>
<TITLE>module monin_obukhov</TITLE>
<BODY BGCOLOR="#AABBCC" TEXT="#332211" >

<DIV ALIGN="CENTER"> <FONT SIZE=1>
<A HREF="#INTERFACE">PUBLIC INTERFACE</A> / 
<A HREF="#ROUTINES">ROUTINES</A> / 
<A HREF="#NAMELIST">NAMELIST</A> / 
<A HREF="#CHANGES">CHANGES</A> / 
<A HREF="#ERRORS">ERRORS</A> / 
<A HREF="#REFERENCES">REFERENCES</A> / 
<A HREF="#NOTES">NOTES</A> 
</FONT>
<P><I>Last updated on <!--#exec cmd="echo $LAST_MODIFIED" -->.</I>
<BR><BR></DIV><HR>


<H2>module monin_obukhov</H2>
<A NAME="HEADER">
<PRE>
     Version: v2.0
     Date:    October 4, 1999
     Contact: Isaac Held
</PRE>
</A><!-- END HEADER -->
<!--------------------------------------------------------------------->
<A NAME="OVERVIEW">
<HR>
<H4>OVERVIEW</H4>
<!-- BEGIN OVERVIEW -->
<PRE>

      Routines for computing surface drag coefficients from
      data at the lowest model level using Monin-Obukhov scaling,
      and for estimating the wind, temperature, and buoyancy profiles
      between the lowest model level and surface

</PRE>
</A><!-- END OVERVIEW -->
<!--------------------------------------------------------------------->
<A NAME="DESCRIPTION">
<!-- BEGIN DESCRIPTION -->
<PRE>

  Monin-Obukhov similarity (MOS) theory is the standard method 
  for computing  surface fluxes from the lowest level winds, 
  temperatures, and tracer mixing ratios in GCMs.  The lowest level 
  is assumed to lie within the "surface layer" in which turbulent 
  fluxes have negligible vertical variation, and in which MOS assumes 
  that the wind and buoyancy profiles are a function only of the 
  surface stress, the surface buoyancy flux, and the height z. 
  A good reference is Garratt, J. R. "The Atmospheric Boundary Layer", 
  Cambridge University Press, 1992.  For a  discussion of the detailed 
  form of the similarity theory used in this module, see  
  <A HREF="monin_obukhov.tech.ps">monin_obukhov.tech.ps</A>

  The similarity functions chosen are

     on the unstable side -- for momentum 
               (1 - 16.0*zeta)**(-0.25)

     on the unstable side -- for temperature
               (1 - 16.0*zeta)**(-0.5)

     on the stable side -- for both momentum and temperature
               1.0 + zeta*(5.0 + b_stab*zeta)/(1.0 + zeta)

     where b_stab = 1/rich_crit 
           (rich_crit is a namelist parameter)

  These similarity functions, phi(zeta), are functions of 
         zeta = z/L, where L is the  Monin-Obukhov length 
  The derivative of the quantity in question with respect 
    to zeta is (1/zeta)*phi(zeta).  for the neutral logarithmic
    profile, phi = 1.

   Drag coefficients for water and all tracers should be set equal 
     to that for temperature

</PRE>
</A><!-- END DESCRIPTION -->
<!--------------------------------------------------------------------->
<A NAME="MODULES_USED">
<HR>
<H4>OTHER MODULES USED</H4>
<!-- BEGIN MODULES_USED -->
<PRE>

    This modules uses 
       constants_mod
       utilities_mod

    It has been tested with versions v1.0 of these modules

</PRE>
</A><!-- END MODULES_USED -->
<!--------------------------------------------------------------------->
<A NAME="INTERFACE">
<HR>
<H4>PUBLIC INTERFACE</H4>
<!-- BEGIN INTERFACE -->
<PRE>

    use monin_obukhov_mod [,only: mo_drag   , &
                                  mo_profile, &
                                  mo_diff   ]

    mo_drag   : computes the drag coefficients for momentum and heat;
                also returns u_star (the friction velocity) and
                b_star (the buoyancy scale)

    mo_profile :  provides the profile of momentum and temperature
                in the constant flux layer -- useful when desiring 
                model output at a standard level below the lowest
                model level.  For example, "surface winds" generally
                refer to the wind at 10 meters above the surface.

    mo_diff : computes the difusivity that, acting in isolation,
              would produce the correct profiles 



  Notes:

    -- mo_drag has a namelist option that allows the drag coefficients
       to be smoothed according to dD/dt = (D - D_eq)/relax_time, where
       D_eq is the instantaneous drag coefficient as produced by the 
       theory, and relax_time is a namelist parameter.  This smoothing
       can be useful for numerical reasons. This procedure
       is performed inside of the module so that the friction velocity
       and buoyancy scales are assured of being consistent with the 
       drag coefficients.

       Several of the routines can be called with either 
       2d or 1d input and output.  
       The base routines are 1d - the 2d routines rearrange the input and
       output into 1d form, which is inefficient.  This choice 
       of the 1d form as the base routine, which contrasts with 
       the choice made for most of the physics modules, arises
       because the calculation of the drag coefficients in the GCM
       takes place on the "exchange grid", which is 1d 




</PRE>
</A><!-- END INTERFACE -->
<!--------------------------------------------------------------------->
<A NAME="ROUTINES">
<HR>
<H4>PUBLIC ROUTINES</H4>
<!-- BEGIN ROUTINES -->
<PRE>

==========================================================================

 call  mo_drag (dt, pt, pt0, z, z0, zt, speed, drag_m, drag_t, &
                u_star, b_star, [mask])

   (In the following the phrase "dimension(:) or (:,:)" means
      that this routine can be called either with all of the 
      variables so designated being either 1d or 2d arrays.
      All of these arrays should conform exactly.)

   input: 

      dt,  real
         time step (seconds)
         only used if the time smoothing is turned on by setting the
         namelist parameter relax_time to a non-zero value

      pt,  real, dimension(:) or (:,:)
         virtual potential temperature at lowest model level
         degrees Kelvin

      pt0, real, dimension(:) or (:,:)
         virtual potential temperature at surface
         degrees Kelvin

      z, real, dimension(:) or (:,:) 
         height above surface of lowest model layer 
         meters

      z0, real, dimension(:) or (:,:)
          surface roughness for momentum 
          meters

      zt, real, dimension(:) or (:,:)
          surface roughness for temperature
          meters

      speed, real, dimension(:) or (:,:) 
          wind speed at lowest model level with respect to surface 
             (any "gustiness" factor should be included in speed)
          meters/sec

   inout:

        drag_m, real, dimension(:) or (:,:)
              non-dimensional drag coefficient for momentum
           

        drag_t, real, dimension(:) or (:,:)
              non-dimensional drag coefficient for temperature

          (the input values are used only if the time-smoothing 
            option is turned on)

   output:

        u_star, real, dimension(:) or (:,:)
           friction velocity 
           meters/sec

        b_star, real, dimension(:) or (:,:)
           buoyancy scale 
           (meters/sec)**2


            The magnitude of the wind stress is 
                 density*(ustar**2)
            The drag coefficient for momentum is 
                 (u_star/speed)**2
            The buoyancy flux is
                 density*ustar*bstar
            The drag coefficient for heat etc is
                 (u_star/speed)*(b_star/delta_b)
                 where delta_b is the buoyancy difference between
                  the surface and the lowest model level

     
      
    optional:
       mask    : logical, dimension(:) 
                   computation performed only where mask = .true.
       NOTE(!) :  mask option is only available for 1d version 

==========================================================================

 subroutine mo_profile(zref, z, z0, zt, u_star, b_star, &
                          del_m, del_h, [mask])

     (In the following the phrase "dimension(:) or (:,:)" means
      that this routine can be called either with all of the 
      variables so designated being either 1d or 2d arrays.
      All of these arrays should conform exactly.)

  input:

     zref, real
           height above surface to which interpolation is requested
           meters

     z, real, dimension(:) or (:,:) 
        height of lowest model layer
        meters

     z0, real, dimension(:) or (:,:)
         surface roughness for momentum 
         meters

     zt, real, dimension(:) or (:,:)
         surface roughness for temperature
         meters

     u_star, real, dimension(:) or (:,:)
             friction velocity 
             meters/sec

     b_star, real, dimension(:) or (:,:)
             buoyancy scale
             (meters/sec)**2

          (Note:  u_star and b_star are output from mo_drag)

    optional input:

       mask, logical, dimension(:) 
                   computation performed only where mask = .true.
       NOTE(!):  mask option is only available for 1d version 


    output:

       del_m, real, dimension(:) or (:,:)
              dimensionless ratio, as defined below, for momentum

       del_h, real, dimension(:) or (:,:)
              dimensionless ratio, as defined below, for temperature

          Ratios are  (f(zref) - f_surf)/(f(z) - f_surf)

==========================================================================
               
  subroutine mo_diff(z, u_star, b_star, k_m, k_h, [mask])

    input: 
        z, real, dimension(see below)
                height above surface of at which diffusivities 
                are desired
                meters

        u_star, real, dimension(see below)
                surface friction velocity
                meters/sec

        b_star, real, dimension(see below)
                buoyancy scale 
                (meters/sec)**2

          (Note:  u_star and b_star are output from mo_drag)

    optional input:
       mask    : logical, dimension(:) 
                   computation performed only where mask = .true.
       NOTE:  mask option is only available for 1d versions -- see below

    output:

        k_m   : real, dimension(see below)
                kinematic diffusivity for momentum 
                (meters**2/sec)

        k_h   : real, dimension(see below)
                kinematic diffusivity for temperature
                (meters**2/sec)

    dimensions:  any of the following four options can be used

      1) diffusivities desired on multiple levels, with 2d (x,y) input
              z(:,:,:), k_m(:,:,:), k_h(:,:,:)
              u_star(:,:), b_star(:,:) corresponding to the 1st and 2nd
                  indices of z -- vertical level is third index
              mask option NOT available

      2) as in 1), but with only 1d input
              z(:,:), k_m(:,:), k_h(:,:)
              u_star(:), b_star(:) corresponding to the 1st index of z
              vertical level is second index
              mask option available

      3) diffusivities desired on one level only, with 2d input
              z(:,:), k_m(:,:), k_h(:,:),u_star(:,:), b_star(:,:) 
              mask option NOT available

      4) diffusivities desired on one level only, with 1d input
              z(:), k_m(:), k_h(:), u_star(:), b_star(:) 
              mask option available

</PRE>
</A><!-- END ROUTINES -->
<!--------------------------------------------------------------------->
<A NAME="NAMELIST">
<HR>
<H4>NAMELIST</H4>
<!-- BEGIN NAMELIST -->
<PRE>

   (default values provided)

    real    :: rich_crit  = 2.0      (non-dimensional)

       The first step in applying the similarity theory is computing
       the bulk Richardson's  number Ri between the lowest model level
       and the surface.
       If Ri is greater than rich_crit, it is reset to rich_crit.
       This provides one means of controlling the poorly understood
       mixing in very stable boundary layers.  

    real    :: drag_min   = 1.e-05   (non-dimensional)

       Provides a simpler way of preventing the mixing in stable 
       layers from getting too small,  The drag coefficients (for
       both momentum and temperature) are not allowed to fall below
       drag_min

    real    :: relax_time = 0.          (seconds)

       If set to a positive value, the drag coefficients
       are smoothed according to dD/dt = (D - D_eq)/relax_time, where
       D_eq is the instantaneous drag coefficient as produced by the 
       theory.  Be sure that relax_time is larger than the timestep
       dt passed to mo_drag
          
    logical :: neutral    = .false.

      If set to .true., all stability dependence is suppressed and 
       neutral logarithmic profiles are used for all calculations


</PRE>
</A><!-- END NAMELIST -->
<!--------------------------------------------------------------------->
<A NAME="CHANGES">
<HR>
<H4>CHANGE HISTORY</H4>
<!-- BEGIN CHANGES -->
<PRE>

<b>changes for v2.0</b> (10/4/99)

     MPP version created. Minor changes for open_file, error_mesg,
     and Fortran write statements. Answers should reproduce the
     previous version.

<b>changes for v1.1</b>

     Minor modification made to the time smoothing option in mo_drag
     Should reproduce v1.0 exactly otherwise

</PRE>
</A><!-- END CHANGES -->
<!--------------------------------------------------------------------->
<A NAME="ERRORS">
<HR>
<H4>ERROR MESSAGES</H4>
<!-- BEGIN ERRORS -->
<PRE>

FATAL ERRORS in MONIN_OBUKHOV_INIT in MONIN_OBUKHOV_MOD

    rich_crit in monin_obukhov_mod must be > 0.25

    drag_min in monin_obukhov_mod must be >= 0.0

FATAL ERROR in solve_zeta in monin_obukhov_mod

    no convergence in surface drag iteration

</PRE>
</A><!-- END ERRORS -->
<!--------------------------------------------------------------------->
<A NAME="REFERENCES">
<HR>
<H4>REFERENCES</H4>
<!-- BEGIN REFERENCES -->
<PRE>

</PRE>
</A><!-- END REFERENCES -->
<!--------------------------------------------------------------------->
<A NAME="BUGS">
<HR>
<H4>KNOWN BUGS</H4>
<!-- BEGIN BUGS -->
<PRE>
None known
</PRE>
</A><!-- END BUGS -->
<!--------------------------------------------------------------------->
<A NAME="NOTES">
<HR>
<H4>NOTES</H4>
<!-- BEGIN NOTES -->
<PRE>

If iteration convergence is ever a problem, one could consider
precomputation and table interpolation

Time smoothing was helpful in idealized testing with extreme diurnal
cycles.  It is not clear that it is needed in realistic GCMs

</PRE>
</A><!-- END NOTES -->
<!--------------------------------------------------------------------->
<A NAME="PLANS">
<HR>
<H4>FUTURE PLANS</H4>
<!-- BEGIN PLANS -->
<PRE>


</PRE>
</A><!-- END PLANS -->
<!--------------------------------------------------------------------->

<HR>
</BODY>
</HTML>
